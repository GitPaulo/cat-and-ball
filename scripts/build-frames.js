#!/usr/bin/env node
import fs from "fs/promises";
import path from "path";

const ASCII_DIR = "ascii";
const OUTPUT_FILE = "gen/frames.js";

const FRAME_NAME_RE = /^frame(\d+)\./;

function frameNumber(name) {
  const m = name.match(FRAME_NAME_RE);
  return m ? Number(m[1]) : Number.POSITIVE_INFINITY;
}

function xmlEscape(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

async function listSubdirs(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  return entries.filter((e) => e.isDirectory()).map((e) => e.name);
}

async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

/**
 * Generate frames.js module with base64-encoded plain SVG text.
 * No compression - Cloudflare Workers will handle that automatically.
 */
async function generateFramesModule() {
  console.log("Generating frames.js module");

  await ensureDir("gen");

  const animIds = await listSubdirs(ASCII_DIR);
  const framesByAnim = {};
  let totalFrames = 0;

  for (const animId of animIds) {
    const animPath = path.join(ASCII_DIR, animId);
    const files = await fs.readdir(animPath);

    const frameTxtFiles = files
      .filter((f) => f.startsWith("frame") && f.endsWith(".txt"))
      .sort((a, b) => frameNumber(a) - frameNumber(b));

    const frames = [];
    for (const file of frameTxtFiles) {
      const txtPath = path.join(animPath, file);
      const base = path.basename(file, ".txt");

      // Read ASCII art
      const content = await fs.readFile(txtPath, "utf-8");
      const lines = content.split("\n").filter((line) => line.length > 0);

      // Build SVG
      const tspans = lines
        .map((line, idx) => {
          const dy = "16";
          return `<tspan x='10' dy='${dy}'>${xmlEscape(line)}</tspan>`;
        })
        .join("");

      const svg =
        "<svg xmlns='http://www.w3.org/2000/svg' width='480' height='96'>" +
        "<rect width='100%' height='100%' fill='#212830'/>" +
        `<metadata>${xmlEscape(base)}</metadata>` +
        "<text font-family='Courier New, monospace' font-size='14' fill='white' xml:space='preserve' y='0'>" +
        tspans +
        "</text></svg>";

      // Base64 encode the plain SVG text
      frames.push(Buffer.from(svg, "utf-8").toString("base64"));
    }

    framesByAnim[animId] = frames;
    totalFrames += frames.length;
    console.log(`Processed animation ${animId}: ${frames.length} frames`);
  }

  // Build deterministic module content sorted by numeric animation id
  const animationIds = Object.keys(framesByAnim).sort((a, b) => Number(a) - Number(b));

  const lines = [];
  lines.push("// Auto-generated by scripts/build-frames.js");
  lines.push("// Do not edit manually");
  lines.push("");
  lines.push("export const FRAMES = {");
  for (const animId of animationIds) {
    lines.push(`  ${animId}: [`);
    for (const frame of framesByAnim[animId]) {
      lines.push(`    "${frame}",`);
    }
    lines.push("  ],");
  }
  lines.push("};");
  lines.push("");
  lines.push(`export const ANIMATION_IDS = [${animationIds.join(", ")}];`);
  lines.push("");

  await fs.writeFile(OUTPUT_FILE, lines.join("\n"), "utf-8");

  const stats = await fs.stat(OUTPUT_FILE);
  const sizeKB = (stats.size / 1024).toFixed(1);

  console.log(`Generated ${OUTPUT_FILE}`);
  console.log(`Animations: ${animationIds.length}, Total frames: ${totalFrames}, Size: ${sizeKB}KB`);
}

async function main() {
  try {
    await generateFramesModule();
    console.log("\nBuild complete");
  } catch (err) {
    console.error("Build failed:", err);
    process.exit(1);
  }
}

main();
